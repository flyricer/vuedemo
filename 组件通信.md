
# 父子组件通信

## 一、props

#### 父组件：
```
<template>
  <div>
    {{msg}}
    <children :changeName='changeName'></children>
  </div>
</template>

changeName() {
    this.msg = '改变父组件'
}
```
#### 子组件：
```
<template>
    <div>
        <p @click="changeName">子组件</p>
    </div>
</template>

props: {
    changeName: {
        type: Function
    }
},
```

## 二、$emit

#### 父组件：
```
<template>
  <div>
    {{msg}}
    <children @changeName='changeName'></children>//:改为@
  </div>
</template>

changeName() {
    this.msg = '改变父组件'
}
```
#### 子组件：
```
<template>
    <div>
        <p @click="handleClick">子组件</p>
    </div>
</template>

handleClick() {
    this.$emit('changeName')
}
```

## 三、.sync修饰符

#### 父组件：
```
<template>
  <div>
    {{msg}}
    <children :foo.sync='msg'></children>
    //语法糖的扩展：<children :foo="msg" @update:foo="val => msg = val"></children>,所以，这个方法其实就是$emit的变形，只不过它是直接绑定数据，而不是函数
  </div>
</template>
```
#### 子组件：
```
<template>
    <div>
        <p @click="handleClick">子组件</p>
    </div>
</template>

handleClick() {
    this.$emit('update:foo', this.message)
}
```

## 四、$parent/$children[i]

#### 父组件：
```
<template>
  <div>
    {{msg}}
    <children></children>
  </div>
</template>

changeName() {
    this.msg = '改变父组件'
}
```
#### 子组件：
```
<template>
    <div>
        <p @click="handleClick">子组件</p>
    </div>
</template>

handleClick() {
    this.$parent.changeName()
}
```

## 五、$refs访问子组件实例的属性

#### 父组件：
```
<children ref='parentref' @click.native="changename"></children>

changename() {
    console.log(this.$refs.parentref.message)
    this.$refs.parentref.handleClick()
},
```
#### 子组件：
```
<template>
    <div>
        <p>{{message}}</p>
    </div>
</template>

handleClick() {
    console.log('子组件')
}
```

## 作用域插槽，父组件访问子组件数据

#### 父组件：
```
<parent v-slot="slotProp">{{ slotProp.text }}</parent>
```
#### 子组件：
```
message:'scopedSlot'

render(h) {
    return h("div", [
      this.$scopedSlots.default({
        text: this.message
      })
    ]);
  },
```

# 不定层级通信

## 一、provide/inject
缺点在于无法确定哪个子组件使用了inject

#### 父组件
```
provide() {
    return {
        getMap: String | Function | Object
    }
},
```
#### 子组件
```
inject:['getMap']
```

## 二、$attrs/$listeners

#### 父组件
```
<parent :name="name" :age="age" :sex="sex" @testChangeName="changeName"></parent>
```

#### 子组件
```
<div>
    <p>{{name}}</p>
    <children v-bind="$attrs" v-on="$listeners"></children>
</div>

props: {
    name: {
      type: String
    }
},
inheritAttrs: false,
```

#### 孙组件
```
<div>
    <p @click="handleClick">{{$attrs}}</p>
</div>

inheritAttrs: false,
handleClick() {
    this.$emit('testChangeName')
}
```

# 同级组件通信

#### 父组件
```
<six v-on:fromFirst="hanlderFromA"></six>
<seven ref="second"></seven>

hanlderFromA (Bmsg) {
    let second = this.$refs.second
    second.$emit('fromLogin', Bmsg)
}
```

#### 同级组件A
```
<div>
    <p @click="$emit('fromFirst','来自A组件')">first组件</p>
</div>
```

#### 同级组件B
```
<div>
    <p>{{Bmsg}}</p>
</div>

created () {
    this.$on('fromLogin', (Bmsg) => {
        this.Bmsg = Bmsg
        console.log('通信成功')
    })
},
```
但这种多重传递还是有点麻烦，因为要在父组件绑定事件及ref，这种传递可用一个中转Bus实现。

## 中转Bus
```
import Vue from 'vue'
export default new Vue()
```

#### 父组件
```
<six></six>
<seven></seven>

<!-- hanlderFromA (Bmsg) {
    let second = this.$refs.second
    second.$emit('fromLogin', Bmsg)
} -->
```

#### 同级组件A
```
<div>
    <p @click="handleClick">first组件</p>
</div>

handleClick () {
    Bus.$emit('fromFirst', '来自A的组件')
}
```

#### 同级组件B
```
<div>
    <p>{{Bmsg}}</p>
</div>

created () {
    Bus.$on('fromFirst', ( Amsg )=> {
        this.Bmsg = Amsg
        console.log('同级组件交互成功')
    })
},
```
这种方法的优势在于，父组件不需要操作ref，也不需要事件中转，只要设置一个函数，在一个组件中绑定，在另一个组件中触发即可，而且不受任何层级限制。